# To Do:
# 1. More messages/minor iteration printing via control$TRACE
# 2. Hessian returned I think is the unconditional function's (i.e.
# the full function with the lagrange multipliers constraints).
# Might look to a strategy to return the hessian of the constrained
# function (via a small call to the lbfgs routine at the optimum?).
# 3. Solver is very sensitive to the TOL and DELTA control parameters.
# Might consider some strategy to control these better?
# 4. Translate subnp function to cpp.
# 5. More benchmarks http://plato.la.asu.edu/bench.html

# SOLNP notes:
# solnp is an augmented lagrangian solver and hence belongs to the 
# class of indirect solvers implementing a sequential unconstrained
# minimization technique (SUMT) via interior or exterior penalty 
# functions. The augmented lagrange solver, particularly when combined
# with an spq solver for the minor step, has been shown to perform
# as well or even better than direct solvers for some problems.

# Notes for cpp translation:
#---------------------------
# BLAS/LAPACK Routines to Use:

# 1. Matrix Multiplication:
# SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
# 2. Matrix Inverse (in place solve)
# SUBROUTINE La_ZGETRF( M, N, A, LDA, IPIV, INFO )
# then SUBROUTINE La_ZGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )
# 3. Equation Solving qr.solve (need to look ar code in qr.default)

# Other:
# 1. Calling function evaluation in R from cpp with dots arguments
# passed to cpp routine then back to R (should pass and set environment
# as in nlminb source)
# 2. Printing messages to R and minor iterations from cpp